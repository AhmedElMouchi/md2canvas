import json
import click
from os import path
from configparser import ConfigParser
import md2canvas.md2json as m2j
import md2canvas.json2canvas as j2c
import md2canvas.util as ut

NOT_SET = "NOT_SET"

@click.command()
@click.argument("notebook_file", type=str, nargs=1)
@click.option("-u", "--url", type=str, default=None,
              help="URL of Canvas course.")
@click.option("-t", "--token", type=str, default=None,
              help="Token string generated by Canvas.")
@click.option("-f", "--token-file", type=str, default=None,
              help="File containing token string generated by Canvas.")
@click.option("-c", "--course-id", type=str, default=None,
              help="ID of the course.")
@click.option("-s", "--save-settings", "save_settings", flag_value=True,
              default=False, help="Set flag to save settings for future use.")
@click.option("-q", "--quiz-id", type=str, default=None,
              help="ID of the quiz, use if updating existing quiz.")
@click.option("-d", "--dump", type=str, default=None,
              help="File to dump JSON string to.")
@click.option("-n", "--no-upload", "no_upload", flag_value=True,
              default=False, help="Set flag to stop uploading of quiz.")
@click.option("-h", "--hush", "hush", flag_value=True,
              default=False, help="Set flag to stop printing other than warnings and errors.")
def md2canvas(url, notebook_file, token, token_file, course_id, save_settings,
                quiz_id, dump, no_upload, hush):
    """
    Parse file into quiz and upload to Canvas.
    """
    # Set printing settings
    ut.hush = hush

    # Check argument validity
    if not notebook_file or not path.exists(notebook_file):
        print("Invalid notebook file.")
        return

    if not notebook_file.endswith(".md") and \
        not notebook_file.endswith(".ipynb"):
        print("Notebook file must be Markdown or Jupyter Notebook.")
        return

    if token and token_file:
        print("Only one of token or token file can be used.")
        return

    if token_file and not path.exists(token_file):
        print("Invalid token file.")
        return

    if no_upload and not dump:
        print("WARNING: not dumping to file or uploading, nothing will happen.")

    # Get/Set configuration
    if token_file:
        with open(token_file, mode="r") as tf:
            token = tf.read()

    config_file = path.join(path.dirname(path.realpath(__file__)), "config.ini")

    config = ConfigParser()
    config.read(config_file)

    if save_settings:
        if url:
            config.set("settings", "url", url)
        if token:
            config.set("settings", "token", token)
        if course_id:
            config.set("settings", "course_id", course_id)

        with open(config_file, "w") as cf:
            config.write(cf)

    if not no_upload:
        if not url:
            url = config.get("settings", "url")
            if url == NOT_SET:
                print("No URL given or in config file.")
                return
        if not token:
            token = config.get("settings", "token")
            if token == NOT_SET:
                print("No token given or in config file.")
                return
        if not course_id:
            course_id = config.get("settings", "course_id")
            if course_id == NOT_SET:
                print("No course ID given or in config file.")
                return

    ut.sprint("Parsing the quiz at " + notebook_file)
    quiz = m2j.parse_quiz(notebook_file)

    if dump:
        with open(dump, "w") as f:
            json.dump(f, quiz)

    if not no_upload:
        ut.sprint("Uploading quiz to Canvas with following settings:")
        ut.sprint("  URL = " + url)
        ut.sprint("  Token = " + token[:4] + (len(token) - 8) * "*" + token[-4:])
        ut.sprint("  Course ID = " + course_id)
        if quiz_id:
            ut.sprint("  Quiz ID = " + quiz_id)
            j2c.update_quiz(quiz, url, token, course_id, quiz_id)
        else:
            j2c.upload_quiz(quiz, url, token, course_id)

@click.command()
def strip_answers():
    # TODO: remove all answer cells from markdown
    return
